---
id: Scope
title: 作用域
---

## 整体导图

**右键保存本地更清晰**
![作用域](https://i.loli.net/2021/08/05/TSNk5BtqUiVXhj7.png)

- 导图加载可能有点慢
- 因为之前笔记都是幕布的不好转 markdown 后续会对格式进行逐一修正

## 作用域和作用域链

### 作用域类型

- 全局作用域
- 函数作用域
- 块级作用域

### 定义到全局作用域场景

- 全局对象下的方法与属性
- 在最外层声明的变量及方法
- 在非严格模式下 未进行声明但是直接进行使用的变量与方法

### 声明的几种方式

- var

  - 在【非函数作用域】下声明的变量都会挂载到 windows 对象下

    - 严格模式【不会阻止】变量挂载到全局变量中

  - 变量提升

    - 默认声明为 undefined

  - 只能被函数的花括号约束

    - if for while 均不能

  - 已经声明的变量 能【再次声明】

- let

  - 声明的变量 在全局环境下 挂载到 【script 对象】下
  - 变量提升

    - 只是【未进行初始化赋值】操作
    - 先使用 后声明的变量 会报错 【暂时性死区】

  - 声明的变量 能被【所有的花括号】 约束
  - 已经声明的变量 无法再次声明 会报错

- const

  - 声明的值 无法再次赋值

    - 基础类型无法修改,引用类型无法修改引用地址

  - 其余参考 let

### 作用域链

- 函数的[[scope]]属性

  - [[scope]]在【预解析】的阶段已经确认

    - 即使函数声明了未使用 它的 scope 也有对应的值

      - 值为 script（最外层用 let 或 const 声明的东西）+ global (全局作用域)

  - 是一个【数组】（由 变量对象组成）

    - 变量对象分别有

      - Global 全局对象 不会做任何优化
      - script 对象 由 let 和 const 声明的变量对象
      - closure（闭包函数名） 闭包对象

        - 会进行优化 仅保存当前作用域能够访问的变量属性

    - 如果未用到某一个层级中的【任何】变量 函数 参数 则该层级不会出现在 scope 中

      - 严格来说不是【逐一一层一层的查找】。是按预解析后的[[scope]]的数组一层一层的查找,从左到右。

  - 实例

    - ```js
      function foo() {
        var a = 1;
        let b = 2;
        function bar() {
          let x = 9;
          function inner() {
            return a + b;
          }
          console.dir(inner);
        }
        console.dir(bar);
        bar();
      }
      foo();
      ```

    - 对应[[scope属性]]

      - ![image-20210805175214003](https://i.loli.net/2021/08/05/HnLQrp2aiufWMBd.png)

- 完整作用域链

  - 组成

    - Global 全局对象

      - 不会做任何优化

    - script 对象 由 let 和 const 声明的变量对象
    - closure（闭包函数名） 闭包对象

      - 进行优化 仅保存当前作用域能够访问的变量属性

    - local 对象 （活动对象）

      - 组成

        - 函数对象
        - var 声明的变量
        - let/const 声明的变量
        - function 声明的变量
        - class 声明的变量
        - this 指向

      - 无法做优化

        - 因为无法在函数预解析时确认,需要在函数执行过程中才能确认
