---
id: JavaScriptGC
title: 垃圾回收
---
## 整体导图
**右键保存本地更清晰**
![垃圾回收](https://i.loli.net/2021/08/04/uVd3mD9WLJsr85a.png)

- 导图加载可能有点慢
- 因为之前笔记都是幕布的不好转markdown  后续会对格式进行逐一修正

## 可达性

#### 固有的可达值的基本集合，这些值明显不能被释放

- 当前函数的局部变量和参数。
- 嵌套调用时，当前调用链上所有函数的变量与参数。
- 全局变量。
- （还有一些内部的）

#### 如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。

#### 几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。

## 垃圾回收算法

### 标记  标记空间中的可达值

- 从根节点出发 遍历所有的对象

	- 根节点

		- 全局遍历window
		- 文档DOM
		- 存在栈上的变量
		- ...

- 可以遍历的就是可达的
- 没有被遍历的对象,不可达的

### 回收[不可达]的值所占据的内容

### 做内存整理

- 回收对象后 内存中会存在大量不连续的空间  

	- 如果需要分配较大的连续内存  就会出现内存不足的情况

- 然后就会整理内容  保证后续内存的正常分配

## 进行垃圾回收的时间

##### 浏览器进行垃圾回收的时候，会暂停JavaScript脚本  等待完成  才会继续执行

### 优化方式

#### 分代收集

  - ##### 主垃圾回收器

    - 负责

    	- 老生代（v8引擎区分两个区域之一）垃圾回收

    		- 内部对象特征

    			- 占用空间大
    			- 存货时间长

    		- 存放长久对象(浏览器区分)

    			- 生命周期长

    				- window
    				- DOM
    				- WEB API
    				- ...

    - [标记---清除]

    	- 标记

    		- 从根元素开始 遍历
    		- 标记能到达的为活动对象
    		- 标记不能到达的为垃圾数据

    	- 清除

    		- 清除上方不能达到的垃圾数据

    - 内存整理

    	- 多次清除后
    	- 图

    		- ![image-20210805180530471](https://i.loli.net/2021/08/05/xGpZQhfgldiKMCS.png)
    		

 - ##### 副垃圾回收器

    - 负责

    	- 新生代（v8引擎区分两个区域之一）垃圾的回收

    		- 存放临时对象(浏览器区分)

    			- 存活时间短

    - 容量

    	- 1--8M

    - 区域分布

    	- 对象区
    - 空闲区

    - 执行过程

    	- 新加入的对象都被放入对象区域
    - 标记清除  剩余的活动对象就复制到空闲区

    		- ![image-20210805180549068](C:\Users\10988\AppData\Roaming\Typora\typora-user-images\image-20210805180549068.png)

    	- 对调对象区域和空闲区    将活动对象放到对象区 等待下次处理

    		- ![](https://i.loli.net/2021/08/05/CapyGgUbmc4kXVf.png)

  - 多次进行新生代的回收 少量进行老生代的回收 

- #### 增量收集

	- 引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理

- #### 闲时收集

	- 只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

## 不同类型的释放时间

### 引用类型

- 无引用被V8回收

### 值类型

- 处于闭包

	- 要等闭包没有引用才会被回收

- 非闭包

	- 等待v8新生代切换的时候回收

## 小知识

### 垃圾回收机制不考虑

- weakMap
- weakSet

### 闭包不会导致内存泄露

- 因为闭包中的变量是我们需要用到的

## 容易导致内存泄露的场景

### 内存泄露

- 「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。

### 意外的全局变量

- 解决方案

	- 使用严格模式

- 在非严格模式下 

	- 函数内 未定义的变量 会在全局对象中创建一个新变量

		- 实例

			- function foo(arg) { bar = 'hello'}

	- 函数内使用this  但是由于this隐式丢失  导致 变量挂在到全局上了

### 被遗忘的计时器或回调函数

- 现代浏览器更先进的垃圾回收算法可以正确的检测及处理了

### 脱离DOM的引用

- 将DOM储存于 对象 或者数组中 

	- 导致DOM有两个引用

		- DOM树中
		- 对象和数组中

